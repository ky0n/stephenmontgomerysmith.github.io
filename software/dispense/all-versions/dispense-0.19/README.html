<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.79 [en] (X11; U; Linux 2.4.2 i386) [Netscape]">
   <meta name="Author" content="Stephen Montgomery-Smith">
   <title>The Distribute Package</title>
</head>
<body bgcolor="#FF99FF">

<center>
<h1>
The Dispense Package</h1></center>

<h2>
Short Description</h2>
The Dispense Package is designed to be an out of the box way to do distributed
programming.&nbsp; For example, suppose you want to count the number of
twin primes (prime numbers <i>p</i> for which <i>p</i>-2 is also prime).&nbsp;
Suppose you have a program <tt>count-primes</tt> which takes as input a
number b, and outputs the number of twin primes between 1,000,000,000 <i>b</i>
and 1,000,000,000 (<i>b</i>+1).&nbsp; If you want a count of primes up
to 10<sup>14</sup>, you create a file <tt>primes-input</tt> which consists
of lines, each containing an integer, starting at 0, and ending at 99999.&nbsp;
So to get the desired count, you would type:
<p><tt>&nbsp;&nbsp;&nbsp; ./count-primes &lt; primes-input > primes-output</tt>
<p>and then add up all the numbers in the file <tt>primes-output</tt>.
<p>Well this program could take a long time to run.&nbsp; So you want to
spread the load over several computers.&nbsp; This package allows you to
do that.&nbsp; You have a central task dispensing computer (call it <tt>dispense.domain</tt>)
where you run the program:
<p><tt>&nbsp;&nbsp;&nbsp; dispense pass-key 3000 10 &lt; primes-input >
primes-output</tt>
<p>and then on several other computers, you type
<p><tt>&nbsp;&nbsp;&nbsp; enact ./count-primes pass-key dispense.domain
3000</tt>
<p>Each <tt>enact</tt> program asks the <tt>dispense</tt> program for a
line from <tt>primes-input</tt>.&nbsp; (In this instance, the <tt>dispense</tt>
program is listening on port 3000, and uses <tt>pass-key</tt> to verify
that the <tt>enact</tt> program is working on the correct problem.)&nbsp;
The <tt>enact</tt> program works on that problem piece, and then sends
the answer back to the <tt>dispense</tt> program.
<p>If for some reason the <tt>enact</tt> program dies, after 10 minutes
the <tt>dispense</tt> program will give that same problem piece to another
<tt>enact</tt>
program.&nbsp; The <tt>dispense</tt> program collects all the outputs from
the <tt>enact</tt> programs, and places them in <tt>primes-output</tt>,
along with other information such as the I.P. address of the computer which
did that particular computation.
<h2>
How to Build</h2>
This package was designed on FreeBSD.&nbsp; It should work fine on Linux.&nbsp;
If you want to help me port it to other Unix's (or even Windows) that would
be great.
<p>This package needs the Berkeley database revision 3.&nbsp; You can find
it at <a href="http://www.sleepycat.com/">http://www.sleepycat.com/</a>
<p>Download the package <a href="all-versions/dispense-0.19.tar.gz">dispense-0.19.tar.gz</a>.&nbsp;
After un-tarring the distribution, and changing to the created directory,
type
<br><tt>&nbsp;&nbsp;&nbsp; make all-enact</tt>
<br><tt>&nbsp;&nbsp;&nbsp; make install-enact</tt>
<br>to create and install the <tt>enact</tt> programs, and
<br><tt>&nbsp;&nbsp;&nbsp; make all-dispense</tt>
<br><tt>&nbsp;&nbsp;&nbsp; make install-dispense</tt>
<br>to make and install the <tt>dispense</tt> programs.&nbsp; To make and
install everything, type
<br><tt>&nbsp;&nbsp;&nbsp; make all</tt>
<br><tt>&nbsp;&nbsp;&nbsp; make install</tt>
<h2>
How to Use</h2>
To use this package, you will need to create two items.&nbsp; You need
to create a program that does your computations, and you need to create
a file that has a list of input values to your program.&nbsp; (For example,
in this package, there is an example of a program called <tt>add</tt>,
that takes two numbers and outputs their sum.)
<h3>
The Program</h3>
The program should accept one line of input, and then create one line of
output in response.&nbsp; Then it should repeat this over again.&nbsp;
The basic structure of the program should be something like this:
<p><tt>main () {</tt>
<br><tt>&nbsp; char input[1000], output[1000];</tt>
<br><tt>&nbsp; setlinebuf(stdout);</tt>
<br><tt>&nbsp; while ((fgets(input,1000,stdin)!=NULL) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; do_computations(input,output);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; puts(output);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; exit(0);</tt>
<br><tt>}</tt>
<p>Be sure that <tt>output</tt> consists of a single line terminated by
the sequence "\n\0".&nbsp; The <tt>setlinebuf(stdout)</tt> is necessary,
unless you use the <tt>-p</tt> option described below.&nbsp; Your program
should always produce some kind of output.&nbsp; If the input data is invalid,
you might like to have it some kind of error message.&nbsp; The program
may be a script.
<h3>
The Enacting Program</h3>
On each computer where you wish to do the computations, you start the <tt>enact</tt>
program as follows:
<p><tt>&nbsp;&nbsp;&nbsp; enact freddy program-name dispense.domain 3000</tt>
<p>where 3000 is replaced by whatever port number the <tt>dispense</tt>
program is using, and "<tt>freddy</tt>" is a password so that the <tt>dispense</tt>
program knows that it is communicating with a legitimate <tt>enact</tt>
program.
<p>You may run this program with some options:
<ul>
<li>
<tt>-f</tt>&nbsp;&nbsp;&nbsp;&nbsp; The program will run in the foreground
(otherwise it will run in the background);</li>

<li>
<tt>-n <i>number</i></tt>&nbsp;&nbsp;&nbsp;&nbsp; Set the "nice" level
of the program --- type "<tt>man nice</tt>" to see what this is about.&nbsp;
The default value is 20, which means that the program will get the lowest
priority in obtaining CPU time.</li>

<li>
<tt>-q <i>number</i></tt>&nbsp;&nbsp;&nbsp;&nbsp; This causes enact to
get several input lines from <tt>dispense</tt> (up to <i><tt>number</tt></i>),
and put them in its own queue, before working on them.&nbsp; This option
is useful if the internet access is bad or intermittent.</li>

<li>
<tt>-t <i>number</i></tt>&nbsp;&nbsp;&nbsp;&nbsp; This asks the <tt>dispense</tt>
program to use this timeout (in minutes) instead of the one <tt>dispense</tt>
is provided.&nbsp; This is useful if the <tt>-q</tt> option is being used.&nbsp;
The dispense program may decide not to honor this value (see below).</li>

<li>
&nbsp;<tt>-p</tt>&nbsp;&nbsp;&nbsp;&nbsp; If this is set, the <tt>enact</tt>
program opens <tt>program-name</tt> using a pseudo terminal.&nbsp; The
effect of this is that <tt>program-name</tt> will automatically have line
buffering for <tt>stdout</tt>.</li>
</ul>

<h3>
The Dispensing Program</h3>
One computer serves as the central dispenser, which gives out the pieces
of the problem.&nbsp; On this computer, run the <tt>dispense</tt> program
as follows:
<p><tt>&nbsp;&nbsp;&nbsp; dispense freddy 3000 5 &lt; input-file >> output-file</tt>
<p>The word "<tt>freddy</tt>" is a password so that only legitimate <tt>enact</tt>
programs can connect.&nbsp; Replace 3000 with the port you want to use.&nbsp;
Generally any number between 1024 and 65535 should be OK.&nbsp; If you
get a "cannot bind" message when you try to start the <tt>dispense</tt>
program, wait a minute, or try another port (see caveats below).&nbsp;
The last number, in our case 5, is the minimum number of minutes to wait
until the <tt>dispense</tt> program decides that an <tt>enact</tt> program
has taken too long to solve a particular problem piece.
<p>You may run this program with a couple of options.
<ul>
<li>
<tt>-c</tt>&nbsp;&nbsp;&nbsp;&nbsp; This option determines how the dispense
program behaves when all the input lines are used up.&nbsp; With this option,
the <tt>dispense program</tt> will quit, leaving the various <tt>enact</tt>
programs on the other computers running.&nbsp; (So if there is another
project coming up, the programs are still running.)&nbsp; Without this
option, the <tt>dispense</tt> program will keep running indefinitely, and
it will tell the various <tt>enact</tt> programs that connect to it to
quit.</li>

<li>
<tt>-t <i>number</i></tt>&nbsp;&nbsp;&nbsp;&nbsp; This is the maximum timeout
that the <tt>dispense</tt> program will allow <tt>enact</tt> to ask for.</li>
</ul>

<h3>
Format of Output File</h3>
Each line in the input file will result in 3 lines in the output file,
which will look something like this
<p><tt>Data from 12.34.56.78:1111 [Thu Dec&nbsp; 6 08:39:13 2001 -6:00]</tt>
<br><tt>input data</tt>
<br><tt>output data</tt>
<p>At the beginning of the output file will be the single line
<p><tt>Starting [Thu Dec&nbsp; 6 08:30:56 2001 -6:00]</tt>
<p>and when the <tt>dispense</tt> program finishes, it will put at the
end of the output file the single line
<p><tt>Finished [Thu Dec&nbsp; 6 08:39:19 2001 -6:00]</tt>
<p>If you want to see how far the project has progressed, count the number
of lines in the output file by typing
<p><tt>&nbsp;&nbsp;&nbsp; wc -l output-file</tt>
<p>which, when the project is finished, will have two more than three times
as many lines as the input file.
<p>If you want to see which hosts have submitted data, and how many lines
each has submitted, type
<p><tt>&nbsp;&nbsp;&nbsp; check-ips output-file</tt>
<h3>
Remarks</h3>
1.&nbsp; Make sure that each problem piece takes a reasonable amount of
time.&nbsp; Otherwise you might flood your internet connection.&nbsp; If
your input file consist of some lines that will take a long time, and some
lines that will take a small amount of time, you can mix up the input file
using the randomize command:
<p><tt>&nbsp;&nbsp;&nbsp; randomize &lt; input-file > randomized-input-file</tt>
<p>2.&nbsp; The purpose of the password is not to provide any kind of real
security --- rather if one is doing several projects, it helps to stop
them getting mixed up (so you should give each project a different password).
<p>3.&nbsp; If the <tt>dispense</tt> program quits for some reason, on
many versions of Unix, the port that it was using may not be available
for a minute or so.&nbsp; If you wish to restart the <tt>dispense</tt>
program, you will get a "cannot bind" error message.&nbsp; The solution
is to wait&nbsp; minute or two.
<p>4.&nbsp; The input lines should be unique.&nbsp; If you require duplicate
input lines (for example, maybe you are doing Monte Carlo integration), 
add an artificial extra parameter to each input line, simply to make them
unique.
<p>5.&nbsp; The lines of input and output must be less than 50,000 characters.
<p>6.&nbsp; This program is early in its development, and it is the author's
first exercise in threaded internet applications, so it may be buggy.
<p>7.&nbsp; This package includes a directory <tt>example-primes</tt>, which
is a program to calculate the number of primes <i>p</i> for which
<i>p</i>-<i>a</i><sub>1</sub>,
<i>p</i>-<i>a</i><sub>2</sub>,...,
<i>p</i>-<i>a</i><sub><i>k</i></sub>
are also prime, for selected sequences 
<i>a</i><sub>1</sub>,
<i>a</i><sub>2</sub>,...,
<i>a</i><sub><i>k</i></sub>.&nbsp;
If it is only counting twin primes that you wish to do, you may be
better off with the sophisticated code available at
<a href="http://www.cs.rpi.edu/research/twinp/">http://www.cs.rpi.edu/research/twinp/</a>.
<p>8.&nbsp; This package also includes a directory <tt>example-polyominoes</tt>,
which are programs to count the number of ways to place polyominoes into 
various shapes.&nbsp;  The code is derived from the package <tt>polyomino-0.4</tt>,
available at <a href="http://faculty.missouri.edu/~stephen/software/#polyominoes">http://faculty.missouri.edu/~stephen/software/#polyominoes</a>, and was
used to verify some of the results at
<a href="http://www.xs4all.nl/~gp/PolyominoSolver/Polyomino.html">http://www.xs4all.nl/~gp/PolyominoSolver/Polyomino.html</a>.
<h3>
What if the Programs Die or the Connection goes down?</h3>
If an <tt>enact</tt> program dies, that is not a problem.&nbsp; If that
<tt>enact</tt>
program was working on a particular problem piece, the <tt>dispense</tt>
program will wait a while, then give that piece to another <tt>enact</tt>
program.&nbsp; You may restart the <tt>enact</tt> program any time you
like.
<p>If the <tt>dispense</tt> program dies, the <tt>enact</tt> programs will
keep retrying to connect every minute for up to two days.&nbsp; Before
restarting the <tt>dispense</tt> program, you want to weed the input file
so that lines that have already been computed don't get done again.&nbsp;
So type
<p><tt>&nbsp;&nbsp;&nbsp; filter-input output-file &lt; input-file > new-input-file</tt>
<p>to create a new input file.&nbsp; (<tt>filter-input</tt> will also check
for duplicate input lines.)
<h2>
Optional Topics:</h2>

<h3>
Killing the Project</h3>
If you simply wish to stop the dispense program, use the <tt>kill</tt>
command.&nbsp; If you wish to kill the project, that is, to have the <tt>dispense</tt>
program continue to run, but for all the <tt>enact</tt> programs that contact
it to quit, use the <tt>kill</tt> command as follows:
<p><tt>&nbsp;&nbsp;&nbsp; kill -USR1 pid</tt>
<p>where <tt>pid</tt> is the process identifier of the <tt>dispense</tt>
program (use <tt>ps</tt> to find this process identifier).&nbsp; On some
systems, you may be able to achieve the same effect with the command
<p><tt>&nbsp;&nbsp;&nbsp; killall -USR1 dispense</tt>
<h3>
Security for the Dispensing Program</h3>
There is a way to restrict which <tt>enact</tt> programs may access the
<tt>dispense</tt>
program based upon IP number.&nbsp; Upon startup, the
<tt>dispense</tt>
program will attempt to read a file in the current directory called <tt>dispense.allow</tt>.&nbsp;
This contains a list of rules that say whether to deny or allow access.&nbsp;
The program applies the first rule that applies.
<p>The rules should look something like
<p><tt>&nbsp;&nbsp;&nbsp; allow 12.34.56.78</tt>
<br><tt>&nbsp;&nbsp;&nbsp; deny 23.34.56.0/24</tt>
<br><tt>&nbsp;&nbsp;&nbsp; deny 0.0.0.0/0</tt>
<p>The first rule will allow access from an <tt>enact</tt> program working
on a host with I.P. address 12.34.56.78.&nbsp; The second rule will deny
access from any <tt>enact</tt> program working on a host with I.P.'s in
the range 23.34.56.0 to 23.34.56.255.&nbsp; The third rule will deny access
from any host.
<p>There will always be two unwritten rules: a first rule:
<br><tt>&nbsp;&nbsp;&nbsp; allow 127.0.0.1</tt>
<br>so localhost always has access, and a last rule
<br><tt>&nbsp;&nbsp;&nbsp; allow 0.0.0.0/0</tt>
<br>so that if none of the written rules apply, then access is allowed.
<p>If you want to change the rules without stopping the <tt>dispense</tt>
program, first rewrite the <tt>dispense.allow</tt> file, then use the <tt>kill</tt>
command:
<p><tt>&nbsp;&nbsp;&nbsp; kill -USR2 pid</tt>
<p>where <tt>pid</tt> is the process identifier of the <tt>dispense</tt>
program.
<h3>
Make Your Own Enacting Programs</h3>
You can make your own special purpose enacting programs.&nbsp; They go
something like this (you write the <tt>do_computations</tt> function):
<p><tt>#include &lt;dispense.h></tt>
<p><tt>void do_computations(char *input, char *output);</tt>
<p><tt>int main(int argc, char **argv) {</tt>
<br><tt>&nbsp; char *input=(void*)0;</tt>
<br><tt>&nbsp; char output[1000];</tt>
<br><tt>&nbsp; prepare_enact(argc,argv,"",0);</tt>
<br><tt>&nbsp; while (1) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; get_dispensed(&amp;input);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; do_computations(input,output);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; send_enacted(output);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<p>Compile the program like this:
<p><tt>&nbsp;&nbsp;&nbsp; cc enact-my-job.c -o enact-my-job -ldispense
-pthread</tt>
<p>Invoke the program thus:
<p><tt>&nbsp;&nbsp;&nbsp; ./enact-my-job pass-key dispense.domain 3000</tt>
<p>with the options <tt>-f,</tt> <tt>-n</tt> and <tt>-t</tt> if you like.
<h3>
Catching the Output of the Dispense Program</h3>
The <tt>dispense</tt> program outputs some useful messages to standard error
(for example, abortive attempts to connect, or how the <tt>dispense.allow</tt>
file is interpreted).&nbsp; 
Normally these messages will simply be output to the
screen.&nbsp; You can save these messages, depending upon which shell you
are using.&nbsp; If you are using <tt>sh</tt> or <tt>bash</tt>, type something like
<p><tt>&nbsp;&nbsp;&nbsp; dispense freddy 3000 5&lt;input-file>>output-file 2>dispense.log&amp;</tt>
<p>If you are using <tt>csh</tt> or <tt>tcsh</tt>, the following will work:
<p><tt>&nbsp;&nbsp;&nbsp; (dispense freddy 3000 5&lt;input-file>>output-file)>&amp;dispense.log&amp;</tt>
<p>Note the use of <tt>>></tt> instead of <tt>></tt> in collecting the 
output to <tt>output-file</tt>.&nbsp; This is appropriate if for some reason
you are restarting <tt>dispense</tt>, as it appends to <tt>output-file</tt>
instead of writing over it.&nbsp;
Note also the final <tt>&amp;</tt> at the end of the command line --- this will
cause <tt>dispense</tt> to run in the background.
<h2>
How it Works (The Protocol)</h2>

<h3>
Overview</h3>
The <tt>dispense</tt> and <tt>enact</tt> programs have a server-client
relationship --- the <tt>dispense</tt> program acts as the server, and
the <tt>enact</tt> program acts as the client.&nbsp; Thus it is the <tt>enact</tt>
program that initiates contact, both to request data to use as input to
the program <tt>program-name</tt> (specified in the argument list of <tt>enact</tt>),
and to send data obtained as output from <tt>program-name</tt>.
<p>Note that all lines sent and received over the TCP/IP network by these
programs must be terminated by the sequence "\r\n", otherwise the programs
will not accept these lines.
<h3>
The Enacting Program</h3>
When the <tt>enact</tt> program is started, it attempts to connect to the
<tt>dispense.domain</tt>
host on the appropriate port, as specified in the argument list.&nbsp;
If it does not succeed, it will keep trying again every minute, until two
days are up, when the program will quit.&nbsp; After it connects, it sends
the lines
<p><tt>&nbsp;&nbsp;&nbsp; connection from enact</tt>
<br><tt>&nbsp;&nbsp;&nbsp; pass-key</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <i>number</i></tt>
<p>to <tt>dispense.domain</tt> where <i><tt>number</tt></i> is the requested
timeout (0 if none is requested).
<p>If the <tt>enact</tt> program wants data to work on, it sends the line
<p><tt>&nbsp;&nbsp;&nbsp; request data</tt>
<p>It then expects to receive one line of data, the input line.&nbsp; If
the input line is "<tt>Finished</tt>", the
<tt>enact</tt> program quits.
<p>If the <tt>enact</tt> program wants to send the results of computations,
it sends three lines
<p><tt>&nbsp;&nbsp;&nbsp; sending data</tt>
<br><tt>&nbsp;&nbsp;&nbsp; input data</tt>
<br><tt>&nbsp;&nbsp;&nbsp; output data</tt>
<p>If the <tt>enact</tt> program fails to send data or receive in any way,
or if the TCP/IP connection is inactive for over a minute, the connection
is broken.&nbsp; When more communication is required, the connection is
reestablished as described above.
<h3>
The Dispensing Program</h3>
The <tt>dispense</tt> program attempts to dispense the various lines sent
to it via <tt>stdin</tt> to the <tt>enact</tt> programs that connect to
it.&nbsp; After the <tt>enact</tt> programs have worked on each line of
input, the <tt>dispense</tt> program collects back the outputs from the
<tt>enact</tt>
programs, and sends those outputs, with their corresponding inputs, to
<tt>stdout</tt>.
<p>The program maintains two internal databases, a queue of inputs <tt>queue_db</tt>,
and a list of inputs ready to use, <tt>use_db</tt>.&nbsp; Initially both
of these databases are empty.&nbsp; The items in <tt>queue_db</tt> have
a number attached to them, which represents the number of minutes before
that item should be moved to <tt>use_db</tt>.&nbsp; Every minute, the <tt>dispense</tt>
program runs a <tt>de_queue</tt> sub-program, which decreases these numbers
in <tt>queue_db</tt> by one, and places those with a negative number into
<tt>use_db</tt>.
<p>The <tt>dispense</tt> program listens on the appropriate port.&nbsp;
When it receives a connection (and assuming that the connection passes
the rules in <tt>dispense.allow</tt>, otherwise the connection is immediately
terminated), it looks at the first three lines.&nbsp; It expects the first
line to be "<tt>connection from enact</tt>", the second line to match <tt>pass-key</tt>,
and the third line to be a number which is a request timeout.&nbsp; Then
the program enters into a loop, providing or receiving data as requested,
until either the client breaks the connection, or until the protocol is
broken.
<p>If next line is "<tt>request data</tt>", the program looks in its database
<tt>use_db</tt>.&nbsp;
If there are any items there, it sends one of them down the connection.&nbsp;
If not, the <tt>dispense</tt> program gets a line from <tt>stdin</tt>,
and if there is such a line, sends that.&nbsp; If <tt>stdin</tt> is at
the end of file, the <tt>dispense</tt> program repeatedly calls the <tt>de_queue</tt>
sub-program until there is an item in <tt>use_db</tt>, which it then sends.&nbsp;
If the <tt>queue_db</tt> is also empty, the <tt>dispense</tt> program acts
as follows depending upon whether the <tt>-c</tt> option has been set or
not.&nbsp; If the option is set, the program simply quits.&nbsp; Otherwise
the program sends the line "<tt>Finished</tt>".
<p>Then the <tt>dispense</tt> program puts the sent data into <tt>queue_db</tt>,
with an attached number equal to the timeout value specified in the argument
list.
<p>If the next line received is "<tt>sending data</tt>", the <tt>dispense</tt>
program receives two more lines.&nbsp; It checks the second line to see
if it is in <tt>queue_db</tt> or <tt>use_db</tt>.&nbsp; If that is the
case, the item is removed from the database that it is in, and the received
second and third lines are sent to <tt>stdout</tt>, along with information
about which host send the data.
<h2>
License Terms</h2>
This program is free software, and available under a very non-restrictive
BSD style license.&nbsp; Read the file <tt>LICENSE</tt> for details.
<h2>
History</h2>
This package is derived from special purpose programs written by Stephen
Montgomery-Smith to solve certain combinatorial problems.&nbsp; The first
project was to compute the number of ways to place the 12 pentominoes and
5 tetrominoes in a 10x8 rectangle - the answer turned out to be 3,386,001,688.&nbsp;
(See
<a href="http://www.xs4all.nl/~gp/PolyominoSolver/Polyomino.html">http://www.xs4all.nl/~gp/PolyominoSolver/Polyomino.html</a>
for details.)
</body>
</html>
